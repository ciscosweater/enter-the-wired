#!/bin/bash
set -euo pipefail

# ACCELA Installation Script
# Part of Enter The Wired project

# Colors (disabled if not interactive terminal)
if [ -t 1 ] && [ -t 0 ]; then
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    YELLOW='\033[1;33m'
    NC='\033[0m'
else
    GREEN=''
    RED=''
    YELLOW=''
    NC=''
fi

# Configuration
GITHUB_REPO="ciscosweater/enter-the-wired"
INSTALL_DIR="$HOME/.local/share/ACCELA"

### global variables for cross-function communication
LATEST_TAG=""
RELEASE_JSON=""
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
###

# Ensure ACCELA.conf has required [General] fields
ensure_accela_conf_general() {
    local CONF_PATH="$HOME/.config/Tachibana Labs/ACCELA.conf"
    local CONF_DIR
    local TMP_FILE

    CONF_DIR="$(dirname "$CONF_PATH")"
    if ! mkdir -p "$CONF_DIR" 2>/dev/null; then
        echo -e "${YELLOW}[WARN] Could not create config directory: $CONF_DIR${NC}" >&2
        return 0
    fi

    if [ ! -f "$CONF_PATH" ]; then
        if ! cat > "$CONF_PATH" <<'EOF'
[General]
auto_skip_single_choice=true
library_mode=true
max_downloads=16
sls_config_management=true
slssteam_mode=true
use_steamless=true
EOF
        then
            echo -e "${YELLOW}[WARN] Could not write config file: $CONF_PATH${NC}" >&2
            return 0
        fi
        return 0
    fi

    TMP_FILE="$(mktemp)"
    if [ -z "$TMP_FILE" ] || [ ! -f "$TMP_FILE" ]; then
        echo -e "${YELLOW}[WARN] Could not create temporary file for config update.${NC}" >&2
        return 0
    fi

    if ! awk '
BEGIN {
    in_general = 0
    saw_general = 0
    saw_auto_skip_single_choice = 0
    saw_library_mode = 0
    saw_max_downloads = 0
    saw_sls_config_management = 0
    saw_slssteam_mode = 0
    saw_use_steamless = 0
}

function print_required_missing() {
    if (!saw_auto_skip_single_choice) print "auto_skip_single_choice=true"
    if (!saw_library_mode) print "library_mode=true"
    if (!saw_max_downloads) print "max_downloads=16"
    if (!saw_sls_config_management) print "sls_config_management=true"
    if (!saw_slssteam_mode) print "slssteam_mode=true"
    if (!saw_use_steamless) print "use_steamless=true"
}

/^\[[^]]+\]$/ {
    if (in_general) {
        print_required_missing()
        in_general = 0
    }

    if ($0 == "[General]") {
        saw_general = 1
        in_general = 1
        saw_auto_skip_single_choice = 0
        saw_library_mode = 0
        saw_max_downloads = 0
        saw_sls_config_management = 0
        saw_slssteam_mode = 0
        saw_use_steamless = 0
    }

    print $0
    next
}

{
    if (in_general) {
        if ($0 ~ /^auto_skip_single_choice[[:space:]]*=/) {
            if (!saw_auto_skip_single_choice) {
                print "auto_skip_single_choice=true"
                saw_auto_skip_single_choice = 1
            }
            next
        }
        if ($0 ~ /^library_mode[[:space:]]*=/) {
            if (!saw_library_mode) {
                print "library_mode=true"
                saw_library_mode = 1
            }
            next
        }
        if ($0 ~ /^max_downloads[[:space:]]*=/) {
            if (!saw_max_downloads) {
                print "max_downloads=16"
                saw_max_downloads = 1
            }
            next
        }
        if ($0 ~ /^sls_config_management[[:space:]]*=/) {
            if (!saw_sls_config_management) {
                print "sls_config_management=true"
                saw_sls_config_management = 1
            }
            next
        }
        if ($0 ~ /^slssteam_mode[[:space:]]*=/) {
            if (!saw_slssteam_mode) {
                print "slssteam_mode=true"
                saw_slssteam_mode = 1
            }
            next
        }
        if ($0 ~ /^use_steamless[[:space:]]*=/) {
            if (!saw_use_steamless) {
                print "use_steamless=true"
                saw_use_steamless = 1
            }
            next
        }
    }

    print $0
}

END {
    if (in_general) {
        print_required_missing()
    } else if (!saw_general) {
        print ""
        print "[General]"
        print "auto_skip_single_choice=true"
        print "library_mode=true"
        print "max_downloads=16"
        print "sls_config_management=true"
        print "slssteam_mode=true"
        print "use_steamless=true"
    }
}
' "$CONF_PATH" > "$TMP_FILE"; then
        rm -f "$TMP_FILE" 2>/dev/null
        echo -e "${YELLOW}[WARN] Could not process config file: $CONF_PATH${NC}" >&2
        return 0
    fi

    if ! mv "$TMP_FILE" "$CONF_PATH" 2>/dev/null; then
        rm -f "$TMP_FILE" 2>/dev/null
        echo -e "${YELLOW}[WARN] Could not update config file: $CONF_PATH${NC}" >&2
        return 0
    fi

    return 0
}

# Check if running on SteamOS (uses AppImage)
is_steamos() {
    if [ -f /etc/os-release ]; then
        source /etc/os-release
        [[ "${ID:-}" == "steamos" ]] && return 0
    fi
    return 1
}

# Check if running on Bazzite (uses AppImage)
is_bazzite() {
    if [ -f /etc/os-release ]; then
        source /etc/os-release
        [[ "${ID:-}" == "bazzite" ]] && return 0
        [[ "${ID_LIKE:-}" == *"bazzite"* ]] && return 0
    fi
    return 1
}

### fetch api data once and store in global variables
fetch_api_data() {
    echo -n -e "${YELLOW}[WAIT]${NC} Fetching latest release info from GitHub... " >&2
    if ! RELEASE_JSON=$(curl -f -sSL --connect-timeout 10 "https://api.github.com/repos/$GITHUB_REPO/releases/latest" 2>/dev/null); then
        echo -e "${RED}FAILED${NC}" >&2
        return 1
    fi
    LATEST_TAG=$(echo "$RELEASE_JSON" | grep -m 1 '"tag_name":' | sed -E 's/.*"tag_name": *"([^"]+)".*/\1/')
    echo -e "${GREEN}DONE!${NC}" >&2
}
###

# Fetch latest ACCELA release from GitHub API
get_latest_release() {
    local asset_type="$1"
    local release_info

    ### use the globally fetched json
    release_info="$RELEASE_JSON"
    ###

    if [ -z "$release_info" ] || echo "$release_info" | grep -q '"message":'; then
        echo -e "${RED}Error fetching release info from GitHub API${NC}"
        return 1
    fi

    # Parse the download URL based on asset type
    case "$asset_type" in
        source)
            echo "$release_info" | grep -o '"browser_download_url": *"[^"]*ACCELA-[^"]*-linux-source\.tar\.gz"' | head -1 | sed 's/"browser_download_url": *"\(.*\)"/\1/'
            ;;
        appimage)
            echo "$release_info" | grep -o '"browser_download_url": *"[^"]*ACCELA-[^"]*-linux-appimage\.tar\.gz"' | head -1 | sed 's/"browser_download_url": *"\(.*\)"/\1/'
            ;;
        *)
            echo ""
            return 1
            ;;
    esac
}

# Install ACCELA
install_accela() {
    ### version check logic before installation
    local LOCAL_VERSION_FILE="$INSTALL_DIR/.version"
    local LOCAL_VERSION="None"
    [ -f "$LOCAL_VERSION_FILE" ] && LOCAL_VERSION=$(cat "$LOCAL_VERSION_FILE")

    if ! fetch_api_data; then return 1; fi

    if [ "$LOCAL_VERSION" == "$LATEST_TAG" ]; then
        echo -e "${GREEN}[INFO] ACCELA is up to date (Version: $LOCAL_VERSION).${NC}"
        ensure_accela_conf_general
        return 0
    fi

    echo -e "\n${YELLOW}╔════════════════════════════════════════════╗"
    echo -e "║           UPDATE AVAILABLE                 ║"
    echo -e "╚════════════════════════════════════════════╝${NC}"
    echo -e "  Current: ${RED}$LOCAL_VERSION${NC}"
    echo -e "  Latest:  ${GREEN}$LATEST_TAG${NC}\n"

    read -p "Do you want to proceed with the installation? [y/N] " confirm < /dev/tty
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "\n${GREEN}[NOTE] Installation cancelled by user.${NC}"
        return 0
    fi
    ###

    echo -e "${GREEN}Installing ACCELA...${NC}"
    echo ""

    # Load os-release for ID detection
    if [ -f /etc/os-release ]; then
        source /etc/os-release
    fi

    # Install .NET SDK 9.0
    echo -e "${GREEN}Installing .NET SDK 9.0...${NC}"
    if ! curl -sSL https://dot.net/v1/dotnet-install.sh | bash -s -- --channel 9.0 --runtime dotnet 2>&1; then
        echo -e "${YELLOW}Warning: .NET SDK installation failed. Continuing anyway...${NC}"
    fi

    export PATH="$HOME/.dotnet:$PATH"

    # Choose URL based on distribution
    local TEMP_ARCHIVE
    local ACCELA_URL
    local LOCAL_ARCHIVE

    # Cleanup to avoid conflicts with previous installation attempts
    rm -rf ACCELA-*-linux-source ACCELA-*-linux-appimage 2>/dev/null || true

    if is_steamos || is_bazzite; then
        echo "Fetching latest AppImage release for SteamOS/Bazzite..."
        ACCELA_URL=$(get_latest_release "appimage")
        TEMP_ARCHIVE="accela_appimage.tar.gz"
        echo "Using AppImage..."
    else
        echo "Fetching latest source release..."
        ACCELA_URL=$(get_latest_release "source")
        TEMP_ARCHIVE="accela_source.tar.gz"
        echo "Using source build..."
    fi

    if [ -z "$ACCELA_URL" ]; then
        echo -e "${RED}Error: Could not find download URL for ACCELA${NC}"
        return 1
    fi

    ### check for local archive in the script directory
    LOCAL_ARCHIVE=$(find "$SCRIPT_DIR" -maxdepth 1 -name "ACCELA*.tar.gz" -type f 2>/dev/null | head -1 || true)
    ###

    if [ -n "$LOCAL_ARCHIVE" ]; then
        echo "Found local archive: $LOCAL_ARCHIVE"
        TEMP_ARCHIVE="$LOCAL_ARCHIVE"
    else
        echo "Downloading ACCELA..."
        if ! curl -L -o "$TEMP_ARCHIVE" "$ACCELA_URL"; then
            echo -e "${RED}Download error. Check URL or connection.${NC}"
            rm -f "$TEMP_ARCHIVE" 2>/dev/null
            return 1
        fi
    fi

    # Verify download was successful (minimum 1KB)
    if [ ! -f "$TEMP_ARCHIVE" ]; then
        echo -e "${RED}Error: Download failed or file is empty.${NC}"
        rm -f "$TEMP_ARCHIVE" 2>/dev/null
        return 1
    fi

    local FILE_SIZE=$(stat -c%s "$TEMP_ARCHIVE" 2>/dev/null || stat -f%z "$TEMP_ARCHIVE" 2>/dev/null || echo 0)
    if [ "$FILE_SIZE" -lt 1024 ]; then
        echo -e "${RED}Error: Downloaded file is too small (corrupted).${NC}"
        rm -f "$TEMP_ARCHIVE" 2>/dev/null
        return 1
    fi

    mkdir -p "$INSTALL_DIR"

    # Clean up any previous installation in INSTALL_DIR
    rm -rf "$INSTALL_DIR"/*

    echo "Extracting archive..."
    ### use a temporary build directory for extraction
    local BUILD_DIR=$(mktemp -d)
    if ! tar -xzf "$TEMP_ARCHIVE" -C "$BUILD_DIR"; then
        echo -e "${RED}Error extracting archive. Download may be corrupted.${NC}"
        rm -f "$TEMP_ARCHIVE" 2>/dev/null
        rm -rf "$BUILD_DIR"
        return 1
    fi
    [ -z "$LOCAL_ARCHIVE" ] && rm "$TEMP_ARCHIVE"

    if ! cd "$BUILD_DIR"; then
        echo -e "${RED}Error: Could not access temporary build directory${NC}"
        return 1
    fi
    ###

    echo "Making installer executable..."
    if [ -f "./ACCELAINSTALL" ]; then
        chmod +x ./ACCELAINSTALL

        echo -e "${GREEN}Running ACCELAINSTALL...${NC}"
        export SKIPVENV="${SKIPVENV:-0}"
        if ! ./ACCELAINSTALL; then
            echo -e "${RED}Error running ACCELAINSTALL.${NC}"
            ### cleanup build dir even on failure
            rm -rf "$BUILD_DIR"
            ###
            return 1
        fi
        ### persist version info after successful run
        echo "$LATEST_TAG" > "$LOCAL_VERSION_FILE"
        ensure_accela_conf_general
        ###
    else
        echo -e "${RED}Error: 'ACCELAINSTALL' not found in extracted folder.${NC}"
        ls -la
        ### cleanup
        rm -rf "$BUILD_DIR"
        ###
        return 1
    fi

    # Clean up installer directory
    echo "Cleaning up temporary files..."
    ### remove the temporary build directory
    rm -rf "$BUILD_DIR"
    ###

    echo -e "${GREEN}[INFO] ACCELA $LATEST_TAG installed successfully!${NC}"
    return 0
}

install_accela "$@"
